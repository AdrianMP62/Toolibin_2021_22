---
title: "EXPLORATORY ANALYSES OF TOOLIBIN AND WALBYRING WATERBIRD COUNTS and INVERTEBRATES INCLUDING 2021-22"
author: "Adrian Pinder"
date: 'Date and time: `r Sys.time()`'
output:
  pdf_document:
    toc: yes
  html_document:
    toc: yes
    number_sections: yes
    toc_float: yes
editor_options:
  chunk_output_type: console
  markdown: 
    wrap: 72
---

```{r, echo=FALSE, include = FALSE}
packages <- c("gridExtra","dendextend","bibliometrix","data.table","mtcars","dplyr","scatterplot3d","plotly","RColorBrewer","stringr","rstudioapi","patchwork","glue","ClassDiscovery","vegan","tidyverse","lubridate","ggplot2","ggpubr","stringi","factoextra", "zoo","cluster","rgl","reshape2","ggthemes","data.table")
lapply(packages, require, character.only=TRUE)
```

Software: Rstudio version: `r rstudioapi::versionInfo()$version`; R version: `r getRversion()`

```{r echo=FALSE, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
knitr::opts_chunk$set(message = FALSE)
knitr::opts_chunk$set(warning = FALSE)
knitr::opts_chunk$set(error = TRUE)
options(scipen=999)
set.seed(12345)
```

# BACKGROUND

Lake Toolibin filled in winter 2021 from rainfall in July/August. Surveys of waterbirds were undertaken across almost all of Lake Toolibin and the downstream Lake Walbyring on Nov 1 and 2 2021 (3 months after filling) and 10-11 Jan 2022 (4.5 months after filling) by boat or (for Jan 2022 at Walbyring) on foot by traversing the perimeter of the lake. Invertebrate surveys were undertaken at the same time using the methods of Cale and Pinder (2019).

Cale and Pinder (2019) analysed patterns in waterbird composition from 1) the 1980s (Jaensch et al., 1985), a survey undertaken in 1996 by Halse <i>et al.</i> (2000) and two 2017 surveys following a summer fill event commencing 9 February 2017. They also analysed invertebrate data collected from both lakes in 1992 (Doupe and Horwitz, 1995), 1996 (Halse <i>et al.</i>, 2000) and 2017. This report extends the Cale and Pinder (2019) analyses of waterbirds and invertebrates to include the 2021/22
data.

# WATERBIRD ANALYSES

The waterbird data input files include depth at time of survey, visit date, period (1980s, 1996, 2017 and 2021/22), an indication (A = ALL_SPECIES) of whether the observers thought they had adequately surveyed the whole of the lake and seen all species (A), whether they were considered pre-salinity reference communities by Froend et al (FHS_Ref), whether they were used as 'comprehensive surveys in these analyses (All_Ref = Y), and species richness.

```{r}
rawdata <- read.csv("./Newdata/Allsurveys18 3.csv", row.names = 1) 
rawdata$VISIT_DATE <- as.Date(rawdata$VISIT_DATE, "%d/%m/%Y") #convert waterbird survey date to R date format
#retain 'rawdata' as an unmodified waterbird import
```

##Graphs of richness by Period for Toolibin and Walbyring

```{r}
rawdata3 <- rawdata
rawdata3$wetland <- str_sub(row.names(rawdata3),1,1) #created new var for Toolibin or Walbyring from survey codes

#Toolibin scatterplot
rawdata3.T <- filter(rawdata3, wetland == "T")
rawdata3.T$colour <- rawdata3.T$All_Ref #new variable (colour) to indicate whether survey is considered reference (Y and N)
rawdata3.T$colour <- gsub('N', 'Blue', rawdata3.T$colour)
rawdata3.T$colour <- gsub('Y', 'Red', rawdata3.T$colour)
rawdata3.T$colour <- gsub('M', 'Black', rawdata3.T$colour)
scat.col <- rawdata3.T$colour
ggplot(data = rawdata3.T, aes(x = Period, y = RICHNESS)) + geom_jitter(aes(colour = colour, alpha = 0.2), size=8, width = 0.05, height = 0.05) + xlab("Period") + ylab("Number of waterbird species") + theme(axis.title.x = element_text(margin=margin(t=20))) + theme(axis.title.y = element_text(margin=margin(r=20))) +theme(axis.text=element_text(size=10), axis.title=element_text(size=14,face="bold")) + theme(legend.position="none") + scale_color_manual(values = c("Blue", "Grey", "Red"))

#Walbyring scatterplot
rawdata3.W <- filter(rawdata3, wetland == "W")
rawdata3.W$colour <- rawdata3.W$All_Ref #new variable (colour) for depth and completeness of surveys
ggplot(data = rawdata3.W, aes(x = Period, y = RICHNESS)) + geom_jitter(aes(colour = colour, alpha = 0.2), size=8, width = 0.05, height = 0.05) + xlab("Period") + ylab("Number of waterbird species") + theme(axis.title.x = element_text(margin=margin(t=20))) + theme(axis.title.y = element_text(margin=margin(r=20))) +theme(axis.text=element_text(size=10), axis.title=element_text(size=14,face="bold")) + theme(legend.position="none") + scale_color_manual(values = c("Blue", "Grey", "Red"))
```

###Multivariate analyses including all surveys (from both lakes) 

All multivariate analyses are performed on Helinger transformed abundance data (within species abundances scaled to values between 0 and 1 and square root transformed). Surveys with richness <=1 removed to deal with an outlier identified in the 2019 analyses. Also removed the 1975 survey as this was not quantitative.

```{r}
comdata <- subset(rawdata, RICHNESS > 1)
comdata <- comdata[!rownames(comdata) == "T1075", ]
comdata.fact <- comdata[, 1:8] #create file with factors
comdata.fact$Survey <- row.names(comdata.fact)
comdata <- comdata[, -(1:8)] #remove factors from data file
comdata[1:5, 1:5] #check first five lines & columns of data file
comdata[is.na(comdata)]<-0 # replace na with 0
comdata.pa<-decostand(comdata,"pa") #create presence/absence matrix
comdata.hel<-decostand(comdata,"hellinger") # create helinger transformed matrix
```

```{r include=FALSE}
mds1 <- metaMDS(comdata.hel, distance ="bray", k=2) #nMDS in 2 dimensions
```

This two-dimensional ordination had unacceptably high stress value (`r round(mds1$stress, digits=2)`) so a 3 dimensional ordination was run with stress `r round(mds2$stress, digits=2)`

```{r include=FALSE}
mds2 <- metaMDS(comdata.hel, distance = "bray", k=3) #nMDS in 3 dimensions
```

```{r}
#Extract mds2 coordinates and create new dataframe with coordinates, survey, and survey period
mds2.pts <- as.data.frame(mds2$points) #extract 2D ordination coordinates (points)
mds2.pts$Survey <- row.names(mds2.pts)
mds2.pts$Period2 <- comdata.fact[match(mds2.pts$Survey, comdata.fact$Survey), 3] #column '2' has 'Period'
```

Below is a plot of axes 1 v 2 of the 3D ordination, showing all of the 1996 to 2022 surveys on the edge of the 1975 and 1980s surveys.

```{r fig.align = 'center'}
#first set axis limits based on maximum values of coordinates
Xmin <- min(mds2.pts$MDS1)*1.2 
Xmax <- max(mds2.pts$MDS1)*1.2
Ymin <- min(mds2.pts$MDS2)*1.2
Ymax <- max(mds2.pts$MDS2)*1.2
ggplot(mds2.pts, aes(x=MDS1, y=MDS2)) + xlim(Xmin,Xmax) + ylim(Ymin,Ymax) + geom_point(aes(colour=Period2), size=5) + coord_fixed(ratio = 1)
```

### Multivariate analyses with only Lake Toolibin data

When just the Toolibin Surveys are considered, an ordination plot still shows the 1996 to 2022 surveys on the edge of the 1980s point cloud.

```{r}
comdataRT <- rawdata[rawdata$RICHNESS > 1, ]
comdataRT <- comdataRT[!rownames(comdataRT) == "T1075", ]
comdataRT[is.na(comdataRT)] <- 0 # replace na with 0
comdataRT <- comdataRT[grep("^T", row.names(comdataRT)),] #extracts Toolibin
comdataRT.fact <- comdataRT[, 1:8]
comdataRT.fact$Survey <- row.names(comdataRT.fact)
comdataRT.fact$YM <- format(as.Date(comdataRT.fact$VISIT_DATE), "%m-%y")
comdataRT.fact$Depthcat <- if_else(comdataRT.fact$DEPTH >0.599, "D", "S") #D = deep, S = shallow
comdataRT.fact$AvN <- paste(comdataRT.fact$ALL_SPECIES, comdataRT.fact$Depthcat) #new variable (colour) for depth and completeness of surveys
comdataRT <- comdataRT[, -(1:8)] #remove factors from data file
comdataRT <- comdataRT[, colSums(comdataRT) != 0]
comdataRT.pa <-decostand(comdataRT,"pa") #create presence/absence matrix
comdataRT.hel <-decostand(comdataRT,"hellinger") # create helinger transformed matrix
row.names(comdataRT.hel) <- comdataRT.fact$VISIT_DATE
comdataRT.sqrt <- sqrt(comdataRT)
```

```{r include=FALSE}
mds6<-metaMDS(comdataRW.hel, distance="bray", k=3) #nMDS in 3 dimensions
```

```{r}
#Extract mds points and add factors
  mds6.pts <- as.data.frame(mds6$points) #extract 2D ordination coordinates (points)
  mds6.pts$Survey <- row.names(comdataRW.fact) #use survey period as row.names
  mds6.pts$YM <- comdataRW.fact$YM #add YearMonth for labelling
  mds6.pts$Period2 <- comdataRW.fact$Period2
  mds6.pts$All_Ref <- comdataRW.fact$All_Ref
  mds6.pts$Depth <- comdataRW.fact$DEPTH
  mds6.pts$AvN <- comdataRW.fact$AvN
  #mds6.pts$Period <- comdataRT.fact[match(row.names(mds6.pts), row.names(comdataRT.fact)), 2]
  #mds6.pts$Depth <- comdataRT.fact[match(row.names(mds6.pts), row.names(comdataRT.fact)), 4]
```

```{r fig.align = 'center'}
Xmin <- min(mds6.pts$MDS1)*1.2
Xmax <- max(mds6.pts$MDS1)*1.2
Ymin <- min(mds6.pts$MDS2)*1.2
Ymax <- max(mds6.pts$MDS2)*1.2
ggplot(mds6.pts, aes(x=MDS1, y=MDS2)) + xlim(Xmin,Xmax) + ylim(Ymin,Ymax) + geom_point(aes(colour=Period2), size=6, alpha=0.8) + coord_fixed(ratio = 1) + scale_color_manual(values = c("dodgerblue4", "deepskyblue2", "cadetblue1", "Grey","Red")) + labs(colour = "Period") 
```

```{r eval = FALSE}
plot(comdataRT.upgma <- hclust(vegdist(comdataRT.hel), method="aver"), hang=1)
tabasco(comdataRT.hel,comdataRT.upgma)
```

### Multivariate analyses with only Lake Walbyring data

```{r}
comdataRW <- rawdata[rawdata$RICHNESS > 4, ]
comdataRW[is.na(comdataRW)] <- 0 # replace na with 0
comdataRW <- comdataRW[grep("^W", row.names(comdataRW)),] #extracts Toolibin
comdataRW.fact <- comdataRW[, 1:8]
comdataRW.fact$Survey <- row.names(comdataRW.fact)
comdataRW.fact$YM <- format(as.Date(comdataRW.fact$VISIT_DATE), "%m-%y")
comdataRW <- comdataRW[, -(1:8)] #remove factors from data file
comdataRW <- comdataRW[, colSums(comdataRW) != 0]
comdataRW.pa <-decostand(comdataRW,"pa") #create presence/absence matrix
comdataRW.hel <-decostand(comdataRW,"hellinger") # create helinger transformed matrix
row.names(comdataRW.hel) <- comdataRW.fact$VISIT_DATE
```

```{r include=FALSE}
mds6<-metaMDS(comdataRW.hel, distance="bray", k=3) #nMDS in 3 dimensions
```

```{r}
#Extract mds points and add factors
  mds6.pts <- as.data.frame(mds6$points) #extract 2D ordination coordinates (points)
  mds6.pts$Survey <- row.names(comdataRW.fact) #use survey period as row.names
  mds6.pts$YM <- comdataRW.fact$YM #add YearMonth for labelling
  mds6.pts$Period2 <- comdataRW.fact$Period2
  mds6.pts$All_Ref <- comdataRW.fact$All_Ref
  mds6.pts$Depth <- comdataRW.fact$DEPTH
  mds6.pts$AvN <- comdataRW.fact$AvN
  #mds6.pts$Period <- comdataRW.fact[match(row.names(mds6.pts), row.names(comdataRW.fact)), 2]
  #mds6.pts$Depth <- comdataRW.fact[match(row.names(mds6.pts), row.names(comdataRW.fact)), 4]
```

Axes 1 v 2 of a 3D ordination with stress
`r round(mds6$stress, digits=3)` showing the 1 x 1996, 2 x 2017 and 2 x
2021-22 surveys on the edge of the 1980s surveys.

```{r fig.align = 'center'}
Xmin <- min(mds6.pts$MDS1)*1.2
Xmax <- max(mds6.pts$MDS1)*1.2
Ymin <- min(mds6.pts$MDS2)*1.2
Ymax <- max(mds6.pts$MDS2)*1.2
ggplot(mds6.pts, aes(x=MDS1, y=MDS2)) + xlim(Xmin,Xmax) + ylim(Ymin,Ymax) + geom_point(aes(colour=Period2), size=6, alpha=0.8) + coord_fixed(ratio = 1) + scale_color_manual(values = c("dodgerblue4", "deepskyblue2", "cadetblue1", "Grey","Red")) + labs(colour = "Period") 
```

```{r eval = FALSE}
plot(comdataRW.upgma <- hclust(vegdist(comdataRW.hel), method="aver"), hang=1)
tabasco(comdataRW.hel,comdataRW.upgma)
```

##Heatmap of species abundances by reference survey for Toolibin Lake
```{r}
comdataHM <- rawdata[rawdata$All_Ref %in% c("Y","M"), ] #selects reference surveys
comdataHM<- comdataHM[!rownames(comdataHM) == "T1075", ] #removes 1975 presence absence data 
comdataHM <- comdataHM[grep("^T", row.names(comdataHM)),] #extracts Toolibin
comdataHM[is.na(comdataHM)] <- 0 # replace na with 0
row.names(comdataHM) <- comdataHM$VISIT_DATE
comdataHM <- comdataHM[, -(1:8)]
comdataHM <- comdataHM[, colSums(comdataHM) != 0]
comdataHM.hel <-decostand(comdataHM,"hellinger") # create helinger transformed matrix
melt_comdataHM.hel <- melt(as.matrix(comdataHM.hel))
ggplot(melt_comdataHM.hel, aes(Var2, Var1)) + geom_tile(aes(fill = value), colour = "white") + theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
  scale_fill_gradient(low = "lightblue", high = "red") + labs(x="Species",y="Survey") + theme(axis.text.y = element_text(colour = c("black", "black","black","black","black","black","black","black","black","black","black","blue", "blue", "blue", "blue", "blue", "blue", "blue")))
```

##Simper analysis of just the reference surveys versus 1996+ surveys for Lake Toolibin
```{r}
comdataRTA <- rawdata[rawdata$All_Ref %in% c("Y","M"), ]
comdataRTA[is.na(comdataRTA)]<-0 # replace na with 0
comdataRTA <- comdataRTA[grep("^T", row.names(comdataRTA)),] #extracts Toolibin
comdataRTA <- comdataRTA[!rownames(comdataRTA) == "T1075", ] #removes 1975 presence absence data 
comdataRTA.fact <- comdataRTA[, 1:8]
comdataRTA <- comdataRTA[, -(1:8)] #remove factors from data file
comdataRTA <- comdataRTA[, colSums(comdataRTA) != 0]
comdataRTA.hel<-decostand(comdataRTA,"hellinger") # create helinger transformed matrix
#simper on transformed data
comdataRTA.Simper <- simper(comdataRTA.hel, comdataRTA.fact$All_Ref)
summary(comdataRTA.Simper)
#simper on untransformed data
comdataRTA.Simper <- simper(comdataRTA, comdataRTA.fact$All_Ref)
summary(comdataRTA.Simper)
```

##Plots of abundance for target species in the management plan.
```{r}
comdataRTA.2 <- as.data.table(comdataRTA)
comdataRTA.2$Period <- comdataRTA.fact$Period2
comdataRTA.2$Period <- ifelse(comdataRTA.2$Period %in% c("1996","2017","2021/22"), comdataRTA.2$Period, "Reference")
```

```{r}
#create new columns for specifying ggplot pch values based on presence/absence of each of the indicator species
comdataRTA.2[, FD.char := ifelse(Freckled.Duck == "0", 1, 16)]
comdataRTA.2$FD.char <- as.factor(comdataRTA.2$FD.char)
comdataRTA.2$Fd.char <- as.factor(comdataRTA.2$FD.char)

comdataRTA.2[, AS.char := ifelse(Australian.Shelduck == "0", 1, 16)]
comdataRTA.2$AS.char <- as.factor(comdataRTA.2$AS.char)
comdataRTA.2$AS.char <- as.factor(comdataRTA.2$AS.char)

comdataRTA.2[, PD.char := ifelse(Pink.eared.Duck == "0", 1, 16)]
comdataRTA.2$PD.char <- as.factor(comdataRTA.2$PD.char)
comdataRTA.2$PD.char <- as.factor(comdataRTA.2$PD.char)

comdataRTA.2[, EC.char := ifelse(Eurasian.Coot == "0", 1, 16)]
comdataRTA.2$EC.char <- as.factor(comdataRTA.2$EC.char)
comdataRTA.2$EC.char <- as.factor(comdataRTA.2$EC.char)

comdataRTA.2[, BS.char := ifelse(Black.winged.Stilt == "0", 1, 16)]
comdataRTA.2$BS.char <- as.factor(comdataRTA.2$BS.char)
comdataRTA.2$BS.char <- as.factor(comdataRTA.2$BS.char)

comdataRTA.2[, GT.char := ifelse(Grey.Teal == "0", 1, 16)]
comdataRTA.2$GT.char <- as.factor(comdataRTA.2$GT.char)
comdataRTA.2$GT.char <- as.factor(comdataRTA.2$GT.char)
```

```{r}
max_y <- max(comdataRTA.2$Freckled.Duck)
FD <- ggplot(comdataRTA.2, aes(x = Period, y = Freckled.Duck, alpha = 0.2, shape = factor(FD.char))) + 
  scale_shape_manual(values = c(1, 16)) +
  geom_jitter(width = 0.05, size = 7, colour="blue") + 
  scale_x_discrete(limits = c("Reference","1996","2017","2021/22")) + 
  theme(legend.position = "none") + 
  theme(axis.text = element_text(size = 12)) + 
  theme(axis.title = element_text(size = 14)) + 
  coord_cartesian(ylim = c(0, max_y*1.1)) +
  ylab("Abundance") + 
  ggtitle("Freckled Duck") + 
  theme(plot.title = element_text(size = 16)) + 
  theme(axis.title.x = element_text(margin = margin(t = 10)), axis.title.y = element_text(margin = margin(r = 10)))

max_y <- max(comdataRTA.2$Australian.Shelduck)
AS <- ggplot(comdataRTA.2, aes(x = Period, y = Australian.Shelduck, alpha = 0.2, shape = factor(AS.char))) + 
  scale_shape_manual(values = c(1, 16)) +
  geom_jitter(width = 0.05, height = 0, size = 7, colour="blue") + 
  scale_x_discrete(limits = c("Reference","1996","2017","2021/22")) + 
  theme(legend.position = "none") + 
  theme(axis.text = element_text(size = 12)) + 
  theme(axis.title = element_text(size = 14)) + 
  coord_cartesian(ylim = c(0, max_y*1.1)) +
  ylab("Abundance") + 
  ggtitle("Australian Shelduck") + 
  theme(plot.title = element_text(size = 16)) + 
  theme(axis.title.x = element_text(margin = margin(t = 10)), axis.title.y = element_text(margin = margin(r = 10)))

max_y <- max(comdataRTA.2$Pink.eared.Duck)
PD <- ggplot(comdataRTA.2, aes(x = Period, y = Pink.eared.Duck, alpha = 0.2, shape = factor(PD.char))) + 
  scale_shape_manual(values = c(1, 16)) +
  geom_jitter(width = 0.05, height = 0, size = 7, colour="blue") +  
  scale_x_discrete(limits = c("Reference","1996","2017","2021/22")) + 
  theme(legend.position = "none") + 
  theme(axis.text = element_text(size = 12)) + 
  theme(axis.title = element_text(size = 14)) + 
  coord_cartesian(ylim = c(0, max_y*1.1)) +
  ylab("Abundance") + 
  ggtitle("Pink-eared Duck") + 
  theme(plot.title = element_text(size = 16)) + 
  theme(axis.title.x = element_text(margin = margin(t = 10)), axis.title.y = element_text(margin = margin(r = 10)))

max_y <- max(comdataRTA.2$Eurasian.Coot)
EC <- ggplot(comdataRTA.2, aes(x = Period, y = Eurasian.Coot, alpha = 0.2, shape = factor(EC.char))) + 
  scale_shape_manual(values = c(1, 16)) +
  geom_jitter(width = 0.05, height = 0, size = 7, colour="blue") + 
  scale_x_discrete(limits = c("Reference","1996","2017","2021/22")) + 
  theme(legend.position = "none") + 
  theme(axis.text = element_text(size = 12)) + 
  theme(axis.title = element_text(size = 14)) + 
  coord_cartesian(ylim = c(0, max_y*1.1)) +
  ylab("Abundance") + 
  ggtitle("Eurasian Coot") + 
  theme(plot.title = element_text(size = 16)) + 
  theme(axis.title.x = element_text(margin = margin(t = 10)), axis.title.y = element_text(margin = margin(r = 10)))

max_y <- max(comdataRTA.2$Black.winged.Stilt)
BS <- ggplot(comdataRTA.2, aes(x = Period, y = Black.winged.Stilt, alpha = 0.2, shape = factor(BS.char))) + 
  scale_shape_manual(values = c(1, 16)) +
  geom_jitter(width = 0.05, height = 0, size = 7, colour="blue") + 
  scale_x_discrete(limits = c("Reference","1996","2017","2021/22")) + 
  theme(legend.position = "none") + 
  theme(axis.text = element_text(size = 12)) + 
  theme(axis.title = element_text(size = 14)) +  
  coord_cartesian(ylim = c(0, max_y*1.1)) +
  ylab("Abundance") + 
  ggtitle("Black-winged Stilt") + 
  theme(plot.title = element_text(size = 16)) + 
  theme(axis.title.x = element_text(margin = margin(t = 10)), axis.title.y = element_text(margin = margin(r = 10)))

max_y <- max(comdataRTA.2$Grey.Teal)
GT <- ggplot(comdataRTA.2, aes(x = Period, y = Grey.Teal, alpha = 0.2, shape = factor(GT.char))) + 
  scale_shape_manual(values = 16) +
  geom_jitter(width = 0.05, height = 0, size = 7, colour="blue") + 
  scale_x_discrete(limits = c("Reference","1996","2017","2021/22")) + 
  theme(legend.position = "none") + 
  theme(axis.text = element_text(size = 12)) + 
  theme(axis.title = element_text(size = 14)) + 
  coord_cartesian(ylim = c(0, max_y*1.1)) +
  ylab("Abundance") + 
  ggtitle("Grey Teal") + 
  theme(plot.title = element_text(size = 16)) + 
  theme(axis.title.x = element_text(margin = margin(t = 10)), axis.title.y = element_text(margin = margin(r = 10)))

grid.arrange(FD, PD, AS, GT, EC, BS, ncol = 2, nrow = 3)
```


```{r}
guilds <- read.csv("./Newdata/ToolibinGuilds.csv") #import Stuart Halse guild data
comdataRTA.guilds <- rawdata[rawdata$All_Ref %in% c("Y","M"), ] #copy raw data and extract only reference and modern surveys
comdataRTA.guilds[is.na(comdataRTA.guilds)]<-0 # replace na with 0
comdataRTA.guilds <- comdataRTA.guilds[grep("^T", row.names(comdataRTA.guilds)),] #extracts Toolibin
comdataRTA.guilds <- comdataRTA.guilds[, -(c(1,2,3,4,5,7,8))] #removes factors other than 'reference' and 'modern' surveys
comdataRTA.guilds$survey <- row.names(comdataRTA.guilds)
comdataRTA.guilds <- reshape2::melt(comdataRTA.guilds) #create long-format file from matrix
comdataRTA.guilds <- comdataRTA.guilds %>% rename_at('variable', ~'Species')
comdataRTA.guilds <- merge(x=comdataRTA.guilds, y=guilds, by="Species", all.x=TRUE);
comdataRTA.guilds <- as.data.table(comdataRTA.guilds[comdataRTA.guilds$value != 0, ]) #remove zero counts
write.csv(comdataRTA.guilds, "./guilds-species.csv")
#sum species richness by guild
comdataRTA.guilds <- comdataRTA.guilds %>% group_by(survey,All_Ref,Guild) %>% summarise(no_rows = length(Guild))
#change column headings
colnames(comdataRTA.guilds) <- c("Survey","Period","Guild","Richness")
#change values for Period
comdataRTA.guilds[comdataRTA.guilds == "Y"] <- "Reference"
comdataRTA.guilds[comdataRTA.guilds == "M"] <- "1996-2022"
#create short-format matrix to add in zero values for missing guilds in each survey
comdataRTA.guilds.m <- dcast(comdataRTA.guilds, formula = Survey ~ Guild, value="Richness", fill=0)
write.csv(comdataRTA.guilds.m, "./guildmatrix.csv")
#convert back to long-format
comdataRTA.guilds.2 <- as.data.table(reshape2::melt(comdataRTA.guilds.m)) #create long-format file from matrix
#add back the Period column by matching back to the original data file
colnames(comdataRTA.guilds.2)[2] <- 'Guild'
colnames(comdataRTA.guilds.2)[3] <- 'Richness'
#add Period back in to datafile
comdataRTA.guilds.2$Period <- comdataRTA.guilds$Period[match(comdataRTA.guilds.2$Survey, c(comdataRTA.guilds$Survey))]
#create new column for values of alpha (transparency) in ggplot
comdataRTA.guilds.2[, alphaprop := ifelse(comdataRTA.guilds.2$Period == "Reference", 0.4, 0.8)]
```

##Scatterplots and boxplots of guild richness by guild
```{r}
ggplot(comdataRTA.guilds.2, aes(x = Period, y = Richness, alpha = 0.4)) +
  geom_jitter(width = 0.1, height = 0.0, size=2, pch=16, colour="blue") + scale_x_discrete(limits = c("Reference", "1996-2022")) + theme(legend.position = "none") +
  scale_alpha_continuous(range = c(0.2, 0.8)) + facet_wrap(vars(Guild))

ggplot(comdataRTA.guilds.2, aes(x = Period, y = Richness, alpha = alphaprop)) +
  geom_violin(colour="blue", fill="lightblue") + scale_x_discrete(limits = c("Reference", "1996-2022")) + theme(legend.position = "none") + facet_wrap(vars(Guild))

ggplot(comdataRTA.guilds.2, aes(Period, Richness)) +
  geom_boxplot(outlier.shape = NA, coef = 0) + scale_x_discrete(limits = c("Reference", "1996-2022")) +
  geom_jitter(width = 0.1, height = 0.1, size=2, pch=16, colour="blue", alpha = 0.3) + theme(legend.position = "none") +
  facet_wrap(vars(Guild))
```

##Heatmap of species abundances for Walbyring
```{r}
comdataHMW <- rawdata[grep("^W", row.names(rawdata)),]
comdataHMW <- comdataHMW[comdataHMW$RICHNESS >4, ]
comdataHMW[is.na(comdataHMW)] <- 0 # replace na with 0
row.names(comdataHMW) <- comdataHMW$VISIT_DATE
comdataHMW <- comdataHMW[, -(1:8)]
comdataHMW <- comdataHMW[, colSums(comdataHMW) != 0]
comdataHMW.hel <-decostand(comdataHMW,"hellinger") # create helinger transformed matrix
melt_comdataHMW.hel <- melt(as.matrix(comdataHMW.hel))
ggplot(melt_comdataHMW.hel, aes(Var2, Var1)) + geom_tile(aes(fill = value), colour = "white") + theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
  scale_fill_gradient(low = "lightblue", high = "red") + labs(x="Species",y="Survey") + theme(axis.text.y = element_text(colour = c("black", "black","black","black","black","black","black","black","black","black","black","black","black","black","black","black","black", "blue", "blue", "blue", "blue", "blue", "blue")))
```


##Simper analysis of just the reference surveys versus 1996+ surveys for Lake Walbyring
```{r}
comdataRWA <- rawdata[rawdata$All_Ref %in% c("N","M"), ]
comdataRWA <- comdataRWA[grep("^W", row.names(comdataRWA)),] #extracts Walbyring
comdataRWA <- comdataRWA[comdataRWA$RICHNESS >4, ]
comdataRWA[is.na(comdataRWA)]<-0 # replace na with 0
comdataRWA.fact <- comdataRWA[, 1:8]
comdataRWA <- comdataRWA[, -(1:8)] #remove factors from data file
comdataRWA <- comdataRWA[, colSums(comdataRWA) != 0]
comdataRWA.hel<-decostand(comdataRWA,"hellinger") # create helinger transformed matrix
#simper on transformed data
comdataRWA.Simper <- simper(comdataRWA.hel, comdataRWA.fact$All_Ref)
summary(comdataRWA.Simper)
#simper on untransformed data
comdataRWA.Simper <- simper(comdataRWA, comdataRWA.fact$All_Ref)
summary(comdataRWA.Simper)
```

# INVERTEBRATES


## Multivariate analysis of composition
```{r include=FALSE}
rawdata.I.orig <- read.csv("./Newdata/Invert matrix for analyses.csv", row.names = 1)
rawdata.I <- rawdata.I.orig[, 2:31] #use only Toolibin-Walbyring data (exclude SPS sites and species names)
rawdata.I <- t(rawdata.I)
row.names(rawdata.I) <- gsub("[.]", "-", row.names(rawdata.I))
Inv.fact.orig <- read.csv("./Newdata/Invert factors.csv", row.names = 1)
Inv.fact <- Inv.fact.orig[1:30, ]
#rawdata.I[is.na(rawdata.I)]<-0 # replace na with 0
```

```{r include=FALSE}
mds1.I <- metaMDS(rawdata.I, distance ="bray", k=2) #nMDS in 2 dimensions
#Extract mds2 coordinates and create new dataframe with coordinates, survey, and survey period
mds1.I.pts <- as.data.frame(mds1.I$points) #extract 2D ordination coordinates (points)
mds1.I.pts$Sample <- row.names(mds1.I.pts)
row.names(mds1.I.pts) <-gsub("[.]", "-", row.names(mds1.I.pts))
#mds1.I.pts$Year <- as.factor(Inv.fact[match(row.names(mds1.I.pts), row.names(Inv.fact)), 1])
mds1.I.pts$Period <- as.factor(Inv.fact[match(row.names(mds1.I.pts), row.names(Inv.fact[1:30, ])), 1])
mds1.I.pts$Survey <- as.factor(Inv.fact[match(row.names(mds1.I.pts), row.names(Inv.fact[1:30, ])), 5])
mds1.I.pts$Wetland <- as.factor(Inv.fact[match(row.names(mds1.I.pts), row.names(Inv.fact[1:30, ])), 3])
mds1.I.pts$Order <- as.factor(Inv.fact[match(row.names(mds1.I.pts), row.names(Inv.fact[1:30, ])), 4])
```

Below is a plot of a 2D ordination of invertebrate samples based on
species presence/absence data, with acceptable stress of
`r round(mds1.I$stress, digits=2)`.This shows the partially developed
community of April 2017 (A17) in both Toolibin and Walbyring (far right
of plot) being very different from other samples collected after longer
periods of inundation. This probably reflects an incompletely developed
community, since samples were collected only 2 months after the fill
event, but maybe also poor water quality and the time of year (see Cale
and Pinder, 2019). This sampling event is useful as an indicator of what
was present early following a summer fill event but does not represent
the contemporary invertebrate values of the lake. All of the Oct 2017,
Nov 2021 and Jan 2022 samples are located closer to, but still separate
from, the 1996 samples. Within the 2021-22 samples, the Nov samples
tended to group separate from the Jan samples suggesting some seasonal
turnover of species composition within the year. The most likely
explanation of the 1996 samples grouping separately to the 2017/21/22
spring/summer samples is the much high salinity (9400 mg/L) in Dec 1996
compared to the freshwater present in Oct 2017 (780), Nov 2021 (1770
mg/L) and Jan 2022 (2000 mg/L). It could be said that the 1996
community, being sampled when the lake was quite saline, was not typical
of invertebrate communities present in what is otherwise considered to
be a freshwater lake.

In three of the five sampling periods the Walbyring samples group
somewhat separate to the Toolibin samples, but for Apr 2017 and November
2021 this is not the case.

```{r fig.align = 'center'}
#first set axis limits based on maximum values of coordinates
Xmin <- min(mds1.I.pts$MDS1)*1.2 
Xmax <- max(mds1.I.pts$MDS1)*1.2
Ymin <- min(mds1.I.pts$MDS2)*1.2
Ymax <- max(mds1.I.pts$MDS2)*1.2
ggplot(mds1.I.pts, aes(x=MDS1, y=MDS2)) + xlim(Xmin,Xmax) + ylim(Ymin,Ymax) + geom_point(aes(colour=Wetland, pch = Survey), size=5) + coord_fixed(ratio = 1) + theme(text = element_text(size=15))
#+ geom_text(aes(label=Sample), size=2, vjust=1, hjust=1.3) #add labels if needed
```

#ordination including six reference sites from Pinder, A.M., S.A. Halse, J.M. McRae, and R. J. Shiel. ‘Aquatic Invertebrate Assemblages of Wetlands and Rivers in the Wheatbelt Region of Western Australia’. Records of the Western Australian Museum Supplement 67 (2004): 7–37.

#create datasets
```{r include=FALSE}
rawdata.I2 <- rawdata.I.orig[, 2:37] #remove species names
rawdata.I2 <- t(rawdata.I2)
row.names(rawdata.I2) <- gsub("[.]", "-", row.names(rawdata.I2))
Inv.fact.orig <- read.csv("./Newdata/Invert factors.csv", row.names = 1) #import site factor variables
Inv.fact2 <- Inv.fact.orig
#rawdata.I[is.na(rawdata.I)]<-0 # replace na with 0
```

#ordination
```{r include=FALSE}
mds2.I <- metaMDS(rawdata.I2, distance ="bray", k=2) #nMDS in 2 dimensions
#Extract mds2 coordinates and create new dataframe with coordinates, survey, and survey period
mds2.I.pts <- as.data.frame(mds2.I$points) #extract 2D ordination coordinates (points)
mds2.I.pts$Sample <- row.names(mds2.I.pts)
row.names(mds2.I.pts) <-gsub("[.]", "-", row.names(mds2.I.pts))
#mds2.I.pts$Year <- as.factor(Inv.fact[match(row.names(mds2.I.pts), row.names(Inv.fact)), 1])
mds2.I.pts$Period <- as.factor(Inv.fact2[match(row.names(mds2.I.pts), row.names(Inv.fact2)), 1])
mds2.I.pts$Survey <- as.factor(Inv.fact2[match(row.names(mds2.I.pts), row.names(Inv.fact2)), 5])
mds2.I.pts$Wetland <- as.factor(Inv.fact2[match(row.names(mds2.I.pts), row.names(Inv.fact2)), 3])
mds2.I.pts$Order <- as.factor(Inv.fact2[match(row.names(mds2.I.pts), row.names(Inv.fact2)), 4])
```

#ordination plot
```{r fig.align = 'center'}
#first set axis limits based on maximum values of coordinates
Xmin <- min(mds2.I.pts$MDS1)*1.2 
Xmax <- max(mds2.I.pts$MDS1)*1.2
Ymin <- min(mds2.I.pts$MDS2)*1.2
Ymax <- max(mds2.I.pts$MDS2)*1.2
ggplot(mds2.I.pts, aes(x=MDS1, y=MDS2)) + xlim(Xmin,Xmax) + ylim(Ymin,Ymax) + geom_point(aes(colour=Wetland, pch = Survey), size=5) + coord_fixed(ratio = 1) + theme(text = element_text(size=15))
#+ geom_text(aes(label=Sample), size=2, vjust=1, hjust=1.3) #add labels if needed
```

#re-run ordination without the April 2017 samples
```{r include=FALSE}
rawdata.I3 <- rawdata.I.orig[, 2:37] #remove species names
rawdata.I3 <- rawdata.I3[, -grep("A17", colnames(rawdata.I3))] #exclude april 2017 columns
rawdata.I3 <- t(rawdata.I3)
row.names(rawdata.I3) <- gsub("[.]", "-", row.names(rawdata.I3))
Inv.fact.orig <- read.csv("./Newdata/Invert factors.csv", row.names = 1) #import site factor variables
Inv.fact3 <- Inv.fact.orig
#rawdata.I[is.na(rawdata.I)]<-0 # replace na with 0
```

#ordination
```{r include=FALSE}
mds3.I <- metaMDS(rawdata.I3, distance ="bray", k=2) #nMDS in 2 dimensions
#Extract mds2 coordinates and create new dataframe with coordinates, survey, and survey period
mds3.I.pts <- as.data.frame(mds3.I$points) #extract 2D ordination coordinates (points)
mds3.I.pts$Sample <- row.names(mds3.I.pts)
row.names(mds3.I.pts) <-gsub("[.]", "-", row.names(mds3.I.pts))
#mds3.I.pts$Year <- as.factor(Inv.fact[match(row.names(mds3.I.pts), row.names(Inv.fact)), 1])
mds3.I.pts$Period <- as.factor(Inv.fact2[match(row.names(mds3.I.pts), row.names(Inv.fact2)), 1])
mds3.I.pts$Survey <- as.factor(Inv.fact2[match(row.names(mds3.I.pts), row.names(Inv.fact2)), 5])
mds3.I.pts$Wetland <- as.factor(Inv.fact2[match(row.names(mds3.I.pts), row.names(Inv.fact2)), 3])
mds3.I.pts$Order <- as.factor(Inv.fact2[match(row.names(mds3.I.pts), row.names(Inv.fact2)), 4])
```

#stress of the above ordination is very high (best 0.19) so repeated as a 3D ordination
```{r include=FALSE}
mds3.I <- metaMDS(rawdata.I3, distance ="bray", k=3) #nMDS in 2 dimensions
#Extract mds2 coordinates and create new dataframe with coordinates, survey, and survey period
mds3.I.pts <- as.data.frame(mds3.I$points) #extract 2D ordination coordinates (points)
mds3.I.pts$Sample <- row.names(mds3.I.pts)
row.names(mds3.I.pts) <-gsub("[.]", "-", row.names(mds3.I.pts))
#mds3.I.pts$Year <- as.factor(Inv.fact[match(row.names(mds3.I.pts), row.names(Inv.fact)), 1])
mds3.I.pts$Period <- as.factor(Inv.fact2[match(row.names(mds3.I.pts), row.names(Inv.fact2)), 1])
mds3.I.pts$Survey <- as.factor(Inv.fact2[match(row.names(mds3.I.pts), row.names(Inv.fact2)), 5])
mds3.I.pts$Wetland <- as.factor(Inv.fact2[match(row.names(mds3.I.pts), row.names(Inv.fact2)), 3])
mds3.I.pts$Order <- as.factor(Inv.fact2[match(row.names(mds3.I.pts), row.names(Inv.fact2)), 4])
mds3.I.pts$Col <- as.character(mds3.I.pts$Wetland)
mds3.I.pts$Col <- replace(mds3.I.pts$Col, mds3.I.pts$Col == "Toolibin", "red")
mds3.I.pts$Col <- replace(mds3.I.pts$Col, mds3.I.pts$Col == "Walbyring", "blue")
mds3.I.pts$Col <- replace(mds3.I.pts$Col, mds3.I.pts$Col == "Reference", "green")
mds3.I.pts$Col <- as.factor(mds3.I.pts$Col)
```


#ordination plot
```{r fig.align = 'center'}
#first set axis limits based on maximum values of coordinates
Xmin <- min(mds3.I.pts$MDS1)*1.2 
Xmax <- max(mds3.I.pts$MDS1)*1.2
Ymin <- min(mds3.I.pts$MDS2)*1.2
Ymax <- max(mds3.I.pts$MDS2)*1.2
ggplot(mds3.I.pts, aes(x=MDS1, y=MDS2)) + xlim(Xmin,Xmax) + ylim(Ymin,Ymax) + geom_point(aes(colour=Wetland, pch = Survey), size=5) + coord_fixed(ratio = 1) + theme(text = element_text(size=15))
#+ geom_text(aes(label=Sample), size=2, vjust=1, hjust=1.3) #add labels if needed
```

```{r}
#create new mds axis scores all >1 so drop lines all go down
mds3.I.pts$MDS1B <- mds3.I.pts$MDS1 + 1.0
mds3.I.pts$MDS2B <- mds3.I.pts$MDS2 + 1.0
mds3.I.pts$MDS3B <- mds3.I.pts$MDS3 + 1.0

#convert Wetland factor to character so can replace values with numbers, then convert to numeric so the drop line calculations work with plot_ly. See https://community.plotly.com/t/droplines-from-points-in-3d-scatterplot/4113
mds3.I.pts$wetland <- as.character(mds3.I.pts$Wetland)
mds3.I.pts['wetland'][mds3.I.pts['wetland'] == 'Toolibin'] <- '1'
mds3.I.pts['wetland'][mds3.I.pts['wetland'] == 'Walbyring'] <- '2'
mds3.I.pts['wetland'][mds3.I.pts['wetland'] == 'Reference'] <- '3'
mds3.I.pts$wetlands <- as.numeric(mds3.I.pts$wetland)

#Duplicate dataset and create new mds3 with 0 values so drop lines go to zero
mds3.I.pts$id <- seq_len(nrow(mds3.I.pts))
ms <- replicate(2, mds3.I.pts, simplify = F)
ms[[2]]$MDS3B <- 0
m <- ms %>%
  bind_rows() %>%
  group2NA("id", "wetland")

plot_ly(color = ~factor(wetland), colors = c("orange", "blue", "red"), showlegend = T) %>%
  add_markers(data = mds3.I.pts, x = ~MDS1B, y = ~MDS2B, z = ~MDS3B) %>%
  add_paths(data = m, x = ~MDS1B, y = ~MDS2B, z = ~MDS3B) %>%
  layout(
    xaxis = list(
      showline = TRUE, # Show x-axis line
      linecolor = 'black', # Color of x-axis line
      linewidth = 2, # Width of x-axis line
      gridcolor = 'rgba(0, 0, 0, 0.5)', # Darker gridlines color
      gridwidth = 1 # Width of gridlines
    ),
    yaxis = list(
      showline = TRUE, # Show y-axis line
      linecolor = 'black', # Color of y-axis line
      linewidth = 2, # Width of y-axis line
      gridcolor = 'rgba(0, 0, 0, 0.5)', # Darker gridlines color
      gridwidth = 1 # Width of gridlines
    ),
    zaxis = list(
      showline = TRUE, # Show z-axis line
      linecolor = 'black', # Color of z-axis line
      linewidth = 2, # Width of z-axis line
      gridcolor = 'rgba(0, 0, 0, 0.5)', # Darker gridlines color
      gridwidth = 1 # Width of gridlines
    ),
    scene = list(
      xaxis = list(
        showline = TRUE, # Show x-axis line
        linecolor = 'black', # Color of x-axis line
        linewidth = 2, # Width of x-axis line
        gridcolor = 'rgba(0, 0, 0, 0.5)', # Darker gridlines color
        gridwidth = 1 # Width of gridlines
      ),
      yaxis = list(
        showline = TRUE, # Show y-axis line
        linecolor = 'black', # Color of y-axis line
        linewidth = 2, # Width of y-axis line
        gridcolor = 'rgba(0, 0, 0, 0.5)', # Darker gridlines color
        gridwidth = 1 # Width of gridlines
      ),
      zaxis = list(
        showline = TRUE, # Show z-axis line
        linecolor = 'black', # Color of z-axis line
        linewidth = 2, # Width of z-axis line
        gridcolor = 'rgba(0, 0, 0, 0.5)', # Darker gridlines color
        gridwidth = 1 # Width of gridlines
      )
    )
  )
```

#cluster analyses by composition for 1996 to 2022 samples (excluding April 2017)
```{r}
clusdist <- vegdist(rawdata.I3, method="bray")
clusanal <- hclust(clusdist, method="average") 
plot(clusanal, xlab="Survey", ylab="Bray")
```

```{r}
str(clusanal)
```

```{r}
stats::rect.hclust
```

```{r}
#create new table with site groups to then create colour codes for plotting cluster analysis
groups <- data.frame(Column1 = rep(NA, 30))
row.names(groups) <- rownames(rawdata.I3)
for (i in 1:nrow(groups)) {
  first_letter <- substr(rownames(groups)[i], 1, 1)
  if (first_letter %in% c("T")) {
    groups[i, "Column1"] <- "blue"
  } else if (first_letter %in% c("W")) {
    groups[i, "Column1"] <- "orange"
  } else {
    groups[i, "Column1"] <- "red"
  }
}




```

```{r}
#create new variable in clusanal with colours for labels by matching labels against groups
groups$labels <- row.names(groups)
matching_indices <- match(clusanal$labels, groups$labels)
clusanal$colour <- as.factor(ifelse(!is.na(matching_indices), groups$Column1[matching_indices], NA))
groups$colour <- clusanal$colour


str(clusanal$labels)
```



#TRYING TO CODE COLOURS INTO CLUSTER PLOT LABELS - CODE FROM https://cran.r-project.org/web/packages/dendextend/vignettes/Cluster_Analysis.html
```{r}
rawdata.I3.2 <- rawdata.I3)
rawdata.I3.2$group <- groups$colour

d_iris <- vegdist(iris2, method = "bray")
hc_iris <- hclust(d_iris, method = "average")
iris_species <- rev(levels(iris[,5]))

library(dendextend)
dend <- as.dendrogram(hc_iris)
# order it the closest we can to the order of the observations:
dend <- rotate(dend, 1:150)

# Color the branches based on the clusters:
dend <- color_branches(dend, k=3) #, groupLabels=iris_species)

# Manually match the labels, as much as possible, to the real classification of the flowers:
labels_colors(dend) <-
   rainbow_hcl(3)[sort_levels_values(
      as.numeric(iris[,5])[order.dendrogram(dend)]
   )]

# We shall add the flower type to the labels:
labels(dend) <- paste(as.character(iris[,5])[order.dendrogram(dend)],
                           "(",labels(dend),")", 
                           sep = "")
# We hang the dendrogram a bit:
dend <- hang.dendrogram(dend,hang_height=0.1)
# reduce the size of the labels:
# dend <- assign_values_to_leaves_nodePar(dend, 0.5, "lab.cex")
dend <- set(dend, "labels_cex", 0.5)
# And plot:
par(mar = c(3,3,3,7))
plot(dend, 
     main = "Clustered Iris data set
     (the labels give the true flower species)", 
     horiz =  TRUE,  nodePar = list(cex = .007))
legend("topleft", legend = iris_species, fill = rainbow_hcl(3))

















```







































Stacked invertebrate richness plots

##Load and format data
```{r}
#create long file for aggregation in next chunks
rawdata.IR.orig <- t(read.csv("./Newdata/Invert matrix for richness2.csv", row.names = 1))
rawdata.IR <- as.matrix(rawdata.IR.orig)
Inv.stack <- as.data.frame(as.table(rawdata.IR))
colnames(Inv.stack) <- c("Sample", "Code", "Presence")
Inv.stack$Wetland <- substr(Inv.stack$Sample, 1, 1) #create new variable for wetland (Toolibin or Walbyring)
Inv.stack$Period <- substr(Inv.stack$Sample, 4,6) #create new variable for survey period
Inv.stack$Period <- gsub("^(?!N|O|J|D).*", "ref", Inv.stack$Period, perl = TRUE) #substitute ref in the Period column
Inv.stack$Sample <-gsub("[.]", "-", Inv.stack$Sample) #convert dot in sample names to a dash for consistency between files (the dots are created on sample import).
Taxonomy3 <- read.csv("./Newdata/Taxonomy3.csv")
colnames(Taxonomy3) <- c("Group", "Group.order", "Code", "LowestID")
Inv.stack$Group <- Taxonomy3[match(Inv.stack$Code, Taxonomy3$Code), 1] #add invertebrate group to the data field to be used for stacking.
Inv.stack$Presence <- as.numeric(Inv.stack$Presence)
Inv.fact.orig <- read.csv("./Newdata/Invert factors.csv", row.names = 1)
```

```{r fig.align = 'center'}
# Aggregate data by taxonomic group and sample for just Lake Toolibin and produce a stacked column plot
Inv.stack.T <- subset(Inv.stack, Wetland %in% c("T","S")) #create Toolibin only dataset
Inv.stack.T.agg <- aggregate(data=Inv.stack.T, Presence ~ Sample + Group, FUN = "sum") #aggregate count data by species and survey
Inv.stack.T.agg <- Inv.stack.T.agg[!Inv.stack.T.agg$Group=="Nematodes", ]
#Inv.fact.orig$Period <- substr(row.names(Inv.fact.orig), 4,6) #not needed now?
Inv.stack.T.agg$Order <- Inv.fact.orig[match(Inv.stack.T.agg$Sample, row.names(Inv.fact.orig)), 4] #add in a variable for ordering the samples on the column plots- from the factor file.
Inv.stack.T.agg$Grouporder <- as.factor(Taxonomy3[match(Inv.stack.T.agg$Group, Taxonomy3$Group), 2]) #add in a variable for ordering the samples on the column plots- from the factor file.
Inv.stack.T.agg < setorder(Inv.stack.T.agg, cols = "Grouporder") #order by taxonomic group
Inv.stack.T.agg$Grouporder <- as.factor(Taxonomy3[match(Inv.stack.T.agg$Group, Taxonomy3$Group), 2]) #add in a variable for ordering the samples on the column plots- from the factor file.
ggplot(Inv.stack.T.agg, aes(x=reorder(Sample, Order), y=Presence, fill=Grouporder)) + 
  geom_bar(stat="identity", colour = "black") +
  scale_fill_manual(values = c("gray75","gray58","gray30","#FFF68F","lavender","white","plum2","#BCEE68","#66CD00","darkcyan","yellowgreen","#7FFFD4","#9AC0CD","#79CDCD","#00FFFF","#98F5FF","deepskyblue2"), labels = c('sponges','hydrozoans','turbellarians','snails','leeches','oligochaetes','water mites','cladocerans','ostracods','copepods','amphipods','beetles','dipterans','hemipterans','lepiodpterans','dragonflies+damselflies','caddisflies')) + 
  xlab("Sample") +
  ylab("Number of invertebrate species") + 
  theme(axis.text = element_text(size = 12)) + 
  theme(axis.title = element_text(size = 15)) +
  theme(axis.text.x=element_text(angle = -90, hjust = 0)) +
  theme(axis.title.y = element_text(vjust = +2.5)) +
  theme(legend.title=element_blank())
```

```{r}
cit <- citation("vegan")
bib_tex <- toBibtex(cit)
print(bib_tex)


```


Need to remove rotifers and protozoans from richness.

```{r fig.align = 'center'}
# Aggregate data by taxonomic group and sampling period for Lake Toolibin and produce stacked column plot of richness
Inv.stack.TW <- Inv.stack.T
Inv.stack.TW$Period <- substr(Inv.stack.T$Sample, 4,6)
Inv.stack.TW.agg <- aggregate(data=Inv.stack.TW, Presence ~ Period + Code, FUN = "sum") #aggregate count data by species and survey
Inv.stack.TW.agg$Group <- Taxonomy3[match(Inv.stack.TW.agg$Code, Taxonomy3$Code), 2] #add invertebrate group to the data field to be used for stacking.
Inv.stack.TW.agg$Presence <- replace(Inv.stack.TW.agg$Presence, Inv.stack.TW.agg$Presence >1, 1)
Inv.stack.TW.agg2 <- aggregate(data=Inv.stack.TW.agg, Presence ~ Period + Group, FUN = "sum") #aggregate count data by species and survey
Inv.stack.TW.agg2$Order <- Inv.fact[match(Inv.stack.TW.agg2$Period, Inv.fact$Period), 3] #add in a variable for ordering the samples on the column plots- from the factor file.
ggplot(Inv.stack.TW.agg2, aes(x=reorder(Period, Order), y=Presence, fill=Group)) + geom_bar(stat="identity", colour = "black") + scale_fill_manual(values = c("#000000","#FF0000","#00FF00","#0000FF","#0099CC", "#FFFF00","#00FFFF","#FF00FF","#808080","#800000","#808000","#008000","#800080","#000080","#C0C0C0"))

#to change order of fills in a stack:
fill = factor(Group, levels=c("Protozoans", "r", "f"))
```

The next two plots are show per sample and per wetland richness for Lake
Walbyring. As was discussed in Cale and Pinder (2019), richness at
Walbyring in 2017 was much lower than it was in 1996, but it increased
moderately in 2021-22. Compared to both 1996 and Oct 2017, the 2021/22
samples had more species of cladocerans, dipterans, hemipterans. By
contrast annelids were present in 1996 and 2021 but absent in 2021/22
and the number of copepod species was lower in 2021/22 than in either
1996 or 2021.

Molluscs were more prevalent in 2021/22 (occurred in a greater
proportion of samples) and. for the first time, included two species in
Jan 2022. Amphipods also returned to Walbyring, having been present in
1996 but not in 2017. By contrast annelids were absent in 2021/22 and
water mites were largely absent, whereas annelids were present in almost
all samples collected in 1996 and 2017 and mites present in all samples
in Oct 2017. Beetles (Coleptera) were as diverse as in 2017 but lower
than in 1996.

```{r fig.align = 'center'}
# Aggregate data by taxonomic group and sample for just Lake Walbyring and produce a stacked column plot
Inv.stack.W <- subset(Inv.stack, Wetland %in% "W") #create Toolibin only dataset
Inv.stack.W.agg <- aggregate(data=Inv.stack.W, Presence ~ Sample + Group, FUN = "sum") #aggregate count data by species and survey
Inv.stack.W.agg$Order <- Inv.fact[match(Inv.stack.W.agg$Sample, row.names(Inv.fact)), 3] #add in a variable for ordering the samples on the column plots- from the factor file.
ggplot(Inv.stack.W.agg, aes(x=reorder(Sample, Order), y=Presence, fill=Group)) + geom_bar(stat="identity", colour = "black") + scale_fill_manual(values = c("#000000","#FF0000","#00FF00","#0000FF","#FF33CC", "#FFFF00","#00FFFF","#FF00FF","#808080","#800000","#808000","#008000","#800080","#000080","#C0C0C0"))
```

```{r fig.align = 'center'}
# Aggregate data by taxonomic group and sampling period for Lake Walbyring and produce stacked column plot of richness
Inv.stack.WW <- Inv.stack.W
Inv.stack.WW$Period <- substr(Inv.stack.T$Sample, 4,6)
Inv.stack.WW.agg <- aggregate(data=Inv.stack.WW, Presence ~ Period + Code, FUN = "sum") #aggregate count data by species and survey
Inv.stack.WW.agg$Group <- Taxonomy3[match(Inv.stack.WW.agg$Code, Taxonomy3$Code), 2] #add invertebrate group to the data field to be used for stacking.
Inv.stack.WW.agg$Presence <- replace(Inv.stack.WW.agg$Presence, Inv.stack.WW.agg$Presence >1, 1)
Inv.stack.WW.agg2 <- aggregate(data=Inv.stack.WW.agg, Presence ~ Period + Group, FUN = "sum") #aggregate count data by species and survey
Inv.stack.WW.agg2$Order <- Inv.fact[match(Inv.stack.WW.agg2$Period, Inv.fact$Period), 3] #add in a variable for ordering the samples on the column plots- from the factor file.
ggplot(Inv.stack.WW.agg2, aes(x=reorder(Period, Order), y=Presence, fill=Group)) + geom_bar(stat="identity", colour = "black") + scale_fill_manual(values = c("#000000","#FF0000","#00FF00","#0000FF","#0099CC", "#FFFF00","#00FFFF","#FF00FF","#808080","#800000","#808000","#008000","#800080","#000080","#C0C0C0"))
```

The next plot shows total richness across both lakes in each sampling
period. Diversity across both lakes was greatest in 1996, despite the
much higher salinity. Total diversity was very slightly lower in 2021/22
than in 2017.

```{r fig.align = 'center'}
# Aggregate data by taxonomic group and sampling period for both lakes and produce stacked column plot of richness
Inv.stack.TW <- Inv.stack
Inv.stack.TW$Period <- substr(Inv.stack.TW$Sample, 4,6)
Inv.stack.TW.agg <- aggregate(data=Inv.stack.TW, Presence ~ Period + Code, FUN = "sum") #aggregate count data by species and survey
Inv.stack.TW.agg$Group <- Taxonomy3[match(Inv.stack.TW.agg$Code, Taxonomy3$Code), 2] #add invertebrate group to the data field to be used for stacking.
Inv.stack.TW.agg$Presence <- replace(Inv.stack.TW.agg$Presence, Inv.stack.TW.agg$Presence >1, 1)
Inv.stack.TW.agg2 <- aggregate(data=Inv.stack.TW.agg, Presence ~ Period + Group, FUN = "sum") #aggregate count data by species and survey
Inv.stack.TW.agg2$Order <- Inv.fact[match(Inv.stack.TW.agg2$Period, Inv.fact$Period), 3] #add in a variable for ordering the samples on the column plots- from the factor file.
ggplot(Inv.stack.TW.agg2, aes(x=reorder(Period, Order), y=Presence, fill=Group)) + geom_bar(stat="identity", colour = "black") + scale_fill_manual(values = c("#000000","#FF0000","#00FF00","#0000FF","#0099CC", "#FFFF00","#00FFFF","#FF00FF","#808080","#800000","#808000","#008000","#800080","#000080","#C0C0C0"))
```

To put composition of the Toolibin and Walbyring invertebrate
communities in a regional context, comparable data from six other good
condition Wheatbelt tree-dominated freshwater wetlands were included in
analyses. These were all sampled in the Biological Survey of the South
West Agricultural Zone by Pinder et al. (2004) in the late 1990s and are
all in the central and southern Wheatbelt. Sampling methods and effort
were identical to that used at Toolibin and Walbyring at a single sample
level. To achieve this some lumping of species to genera level was used
to make taxonomic composition more comparable, especially for beetles.

```{r include=FALSE}
rawdata.IP <- rawdata.I.orig
row.names(rawdata.IP) <- gsub("[.]", "-", row.names(rawdata.IP))
Inv.fact.IP <- Inv.fact.orig
rawdata.IP[is.na(rawdata.IP)]<-0 # replace na with 0
```

## Multivariate analysis of composition

```{r include=FALSE}
mds1.IP <- metaMDS(rawdata.IP, distance ="bray", k=2) #nMDS in 2 dimensions
#Extract mds2 coordinates and create new dataframe with coordinates, survey, and survey period
mds1.IP.pts <- as.data.frame(mds1.IP$points) #extract 2D ordination coordinates (points)
mds1.IP.pts$Sample <- row.names(mds1.IP.pts)
row.names(mds1.IP.pts) <-gsub("[.]", "-", row.names(mds1.IP.pts))
mds1.IP.pts$Year <- as.factor(Inv.fact.IP[match(row.names(mds1.IP.pts), row.names(Inv.fact.IP)), 1])
```

The ordination shows communities for these six 'SAP' sites (purple
circles) around the periphery of the cloud of Toolibin/Walbyring
samples. This suggests the Toolibin and Walbyring communities are not
greatly different from these other samples

```{r fig.align = 'center'}
#first set axis limits based on maximum values of coordinates
Xmin <- min(mds1.IP.pts$MDS1)*1.2 
Xmax <- max(mds1.IP.pts$MDS1)*1.2
Ymin <- min(mds1.IP.pts$MDS2)*1.2
Ymax <- max(mds1.IP.pts$MDS2)*1.2
ggplot(mds1.IP.pts, aes(x=MDS1, y=MDS2)) + xlim(Xmin,Xmax) + ylim(Ymin,Ymax) + geom_point(aes(colour=Year), size=5) + coord_fixed(ratio = 1) + geom_text(aes(label=Sample), size=2, vjust=1, hjust=1.3)
```

This is the same ordination plot but with size of symbols scaled to
richness (cubed for exaggeration) of the communities. This indicates
that most of the Toolibin and Walbyring samples, other than those
sampled in April 2017, had communities that were as rich as these other
wetlands.

```{r fig.align = 'center'}
mds1.IP.pts$Richness <- rowSums(rawdata.IP)
ggplot(mds1.IP.pts, aes(x=MDS1, y=MDS2, size=Richness)) + xlim(Xmin,Xmax) + ylim(Ymin,Ymax) + geom_point(aes(fill=Year), pch=21) + coord_fixed(ratio = 1) + geom_text(aes(label=Sample), size=2, vjust=1, hjust=1.3) + scale_size(range = c(1, 10))
```

Repeat ordination without April 2017 data. In this case stress is \>0.18
so axes 1v2 of a 3D ordination is used.

```{r, include=FALSE}
rawdata.noA17 <- as.data.frame(rawdata.I.orig) %>% filter(!str_detect(rownames(rawdata.I.orig), 'A17'))
row.names(rawdata.noA17) <- gsub("[.]", "-", row.names(rawdata.noA17))
Inv.fact.noA17 <- as.data.frame(Inv.fact.IP) %>% filter(!str_detect(rownames(Inv.fact.IP), 'A17'))
rawdata.noA17[is.na(rawdata.noA17)]<-0 # replace na with 0
```

```{r include=FALSE}
mds1.noA17 <- metaMDS(rawdata.noA17, distance ="bray", k=3) #nMDS in 2 dimensions
#Extract mds2 coordinates and create new dataframe with coordinates, survey, and survey period
mds1.noA17.pts <- as.data.frame(mds1.noA17$points) #extract 2D ordination coordinates (points)
mds1.noA17.pts$Sample <- row.names(mds1.noA17.pts)
row.names(mds1.noA17.pts) <-gsub("[.]", "-", row.names(mds1.noA17.pts))
mds1.noA17.pts$Year <- as.factor(Inv.fact.noA17[match(row.names(mds1.noA17.pts), row.names(Inv.fact.noA17)), 1])
```

```{r, include=FALSE}
mds1.noA17.pts$Richness <- rowSums(rawdata.noA17)
```

```{r fig.align = 'center'}
#first set axis limits based on maximum values of coordinates
Xmin <- min(mds1.noA17.pts$MDS1)*1.2 
Xmax <- max(mds1.noA17.pts$MDS1)*1.2
Ymin <- min(mds1.noA17.pts$MDS2)*1.2
Ymax <- max(mds1.noA17.pts$MDS2)*1.2
ggplot(mds1.noA17.pts, aes(x=MDS1, y=MDS2)) + xlim(Xmin,Xmax) + ylim(Ymin,Ymax) + geom_point(aes(fill=Year), pch=21, size=10) + coord_fixed(ratio = 1) + geom_text(aes(label=Sample), size=2, vjust=1, hjust=1.3)
```

The Toolibin and Walbyring samples are overlaid on a plot of salinity

```{r}
TWrich <- read.csv("./Data/SAP sal richness.csv", row.names = 1)
TWrich$Period <- as.factor(TWrich$Period)
```

```{r}
ggplot(TWrich) + geom_point(aes(salinity, SAPrichness, colour=Period), pch=21, size=5) + scale_x_log10() + geom_point(aes(salinity, TWrichness, colour=Period), pch=19, size=5)
```

```{r}
TWrich <- read.csv("./Data/SAP sal richness2.csv", row.names = 1)
TWrich$Period <- as.factor(TWrich$Period)
str(TWrich)
```

```{r}
ggplot(TWrich, aes(salinity, SAPrichness, colour=Period, size=5)) + scale_x_log10() + geom_point(colour=Period) + scale_shape_manual(values = c(19,1,1,1,1))


ggplot(TWrich, aes(x = salinity, y = SAPrichness)) + geom_point(aes(colour="black", shape=factor(Period), fill=factor(Period)), size=5) + scale_shape_manual(values = c(1,19,19,19,19)) + scale_fill_manual(values=c("white", "red", "blue", "green", "black")) + scale_x_log10() 


p <- ggplot(TWrich, aes(salinity, SAPrichness)) +
  geom_point(aes(colour = factor(Period)))
p + scale_fill_manual(values = c("white", "red", "blue", "green", "black"))



```
